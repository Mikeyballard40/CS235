----- May 5 ----- 

Tool chain

C/C++ Code -> Source Files (source file has syntax, is more readable)
{
 -> preprocessor : looks for lines that start with a pound sign (string substitutions, include other files, etc.) LOOK UP LATER
 -> Translation Units : LOOK UP
 -> Code Generator : creates instructions that the computer can do (CODE)
 -> Assembly code : 1 and 0 s (Assembler code)
 -> object Files : LOOK UP (Object code)
} - note that these comprize the compiler
 -> Linker : draw that code in and cobine it with other object Files
 -> Object Files Executable (machine code)

Translation unit : Basic unit of compilation in C++ (COMPILER)
    a single translation unit can be complied into an object file
    "static" limits scope to the translation unit - function remains local
    "extern" allows global variables to be shared


Compiler vs Interpreters
Compiler
    Goes through a compiler which creates assembly. then an assembler which produces object code. then linker which creates machine code then application which the computer reads
        this is extremely fast.

Interpreters   
    the interpretive languae is the source code for an interpreter which is then read by the computer. 
        if the correct interpreter is on your machine it can run your code. 

Parts of an Algorithm
    It has begining, it has an end, and each step needs to be Executable

**** 
    C++ will teach me the the computers Memory Model.
****

Memory Model
    A byte is a sequence of 8 or more bits and "bit" is a unit of storage large enough to hold one of two values
    each byte is associated with a unique identifier known as its address

## Memory Model
Stack : writable, non-executable, managed automatically by compiler, local variables
available memory : stack and dynamic memory extend into available memory
Dynamic Data(heap) : writable, non-executable, malloc/free new/delete
Static(global variables) : un-initialized
inittialized Data : initialized global variables
Program code : read by the program

EX:
```
int x;
int mian(int argc, char* argv[])
{
    int y;
    int*z = (int*)malloc(10):
}
```

//the contents of all 6 lines fall in program code
x falls into static Data
argc falls into stack bc it is generated by the code.
y would fall into stack being a local variable
(int*) which preceeds malloc(10) would fall into dynamic data
z would fall into stack and point to the 10 bytes referenced by (int*)malloc(10) which falls into dynamic data

## Vocabulaty
Algorithm 
    finiteness
        must terminate
    definiteness
        each step is precisely stated
    effective coputability
        each step can be carried out 
    ***
        start with a problem
        decompose each task into few simple subtasks
        continue to decompose subtasks until we get to something the computer can do


resolution operator
    using classes!!

```
class Vehicle
{
    public: //this allows it to be accessed in the global frame
    void drive() { cout << "Vehicle"; }
};
class Car
{
    public: 
    void drive() { cout << "Car"; }
};
Class BMW : Public Car, Public Vehicle
{}
int main(_____)
{
    BMW bmw;
    bmw.drive();            //Error!
    bmw.Car::drive(); //Drive Car
    bmw.Vehicle::drive(): //Drive Vehicle

}
```


# C++ coding format 

## Scope
```
foo()
{
    int *p;
    {
        int x = 5; 
        p = &x;
    }
    int y = *p;
}
// x is defined within the currly brackets, and thus when p is called outside th brackets it exhibits undefined behavior. That is scope. x must be called where p is initialized. 
```

## Declarations and functions
Namespace

    declarative region that provides a scope to the identifiers inside it.
        (the names of types, functions, variables, etc.)
    great for creating effective scope

```
namespace myNamespace
{
    int a, b;
}

using namespace std;
using namespace myNamespace;
a = 10
b = 20
cout <<"a="<<a<<"b="<<b;

ifstream - input file stream : used to open files
    ifstream in(argv[1]);
    if (!in) return 1; // if it this resulted in an error return 1
```


## Arguments
### Argc and argv
EX:
#include <iostream>
#include <string>
using namespace std;

```
int main(int argc, char* argv[])
{
    cot << endl << "argc = " << argc;
    for (int i = 0; i < argc ; ++i)
    {
        cout << endl << :"argv[" << i << "] = ";
        cout << argv[i];
    }
    return 0;
}
```

// the size of argv[] is argc.
// argv[] is an array of pointers to char*


## Conditional formating
```
    ostream& out = (argc > 2) ? *(new ofstream(argv[2])) : cout;
    <boolean> ? <true expression> : <false expression>
```
## looping
```
int main(int argc, char* argv[])
{ 
    ifstream in(argv[1]);
    if (!in) return 1;
    ostream& out = (argc > 2) ? *(new ofstream(argv[2])) : cout;
    if (!out) return 2;

    string line;
    while (in >> line)
    {
        out << line << endl;
    }
    if (&out != &cout) delete(&out);
    in.close();
    return 0;
}
```

Preprocessors
"#define" = set a variable to a value - #define MATHSCORE 100
"#include" = insert a particular header from another file
"#if and #endif

```
Control Statements
    Selection
        if
        if-else
        switch - a series of if statements. If this or this or this then this.
    iteration
        loops
    Jump
        break
        continue
        return
```

## Iteration
```
int rows = 2;
int cols = 3;
int## array = new int*[rows];
for(int i = 0; i < rows: ++i)
    array[i] = new int[cols]
```


