----- May 5 ----- 


g++ "Lab 1.cpp" -o grades

./run InputFile.txt OutputFile.txt



Tool chain

C/C++ Code -> Source Files (source file has syntax, is more readable)
{
 -> preprocessor : looks for lines that start with a pound sign (string substitutions, include other files, etc.) LOOK UP LATER
 -> Translation Units : LOOK UP
 -> Code Generator : creates instructions that the computer can do (CODE)
 -> Assembly code : 1 and 0 s (Assembler code)
 -> object Files : LOOK UP (Object code)
} - note that these comprize the compiler
 -> Linker : draw that code in and cobine it with other object Files
 -> Object Files Executable (machine code)

Translation unit : Basic unit of compilation in C++ (COMPILER)
    a single translation unit can be complied into an object file
    "static" limits scope to the translation unit - function remains local
    "extern" allows global variables to be shared


Compiler vs Interpreters
Compiler
    Goes through a compiler which creates assembly. then an assembler which produces object code. then linker which creates machine code then application which the computer reads
        this is extremely fast.

Interpreters   
    the interpretive languae is the source code for an interpreter which is then read by the computer. 
        if the correct interpreter is on your machine it can run your code. 

Parts of an Algorithm
    It has begining, it has an end, and each step needs to be Executable

**** 
    C++ will teach me the the computers Memory Model.
****

Memory Model
    A byte is a sequence of 8 or more bits and "bit" is a unit of storage large enough to hold one of two values
    each byte is associated with a unique identifier known as its address

## Memory Model
Stack : writable, non-executable, managed automatically by compiler, local variables
available memory : stack and dynamic memory extend into available memory
Dynamic Data(heap) : writable, non-executable, malloc/free new/delete
Static(global variables) : un-initialized
inittialized Data : initialized global variables
Program code : read by the program

EX:
```
int x;
int mian(int argc, char* argv[])
{
    int y;
    int*z = (int*)malloc(10):
}
```

//the contents of all 6 lines fall in program code
x falls into static Data
argc falls into stack bc it is generated by the code.
y would fall into stack being a local variable
(int*) which preceeds malloc(10) would fall into dynamic data
z would fall into stack and point to the 10 bytes referenced by (int*)malloc(10) which falls into dynamic data

## Vocabulaty
Algorithm 
    finiteness
        must terminate
    definiteness
        each step is precisely stated
    effective coputability
        each step can be carried out 
    ***
        start with a problem
        decompose each task into few simple subtasks
        continue to decompose subtasks until we get to something the computer can do


resolution operator
    using classes!!

```
class Vehicle
{
    public: //this allows it to be accessed in the global frame
    void drive() { cout << "Vehicle"; }
};
class Car
{
    public: 
    void drive() { cout << "Car"; }
};
Class BMW : Public Car, Public Vehicle
{}
int main(_____)
{
    BMW bmw;
    bmw.drive();            //Error!
    bmw.Car::drive(); //Drive Car
    bmw.Vehicle::drive(): //Drive Vehicle

}
```


# C++ coding format 

## Scope
```
foo()
{
    int *p;
    {
        int x = 5; 
        p = &x;
    }
    int y = *p;
}
// x is defined within the currly brackets, and thus when p is called outside th brackets it exhibits undefined behavior. That is scope. x must be called where p is initialized. 
```

## Declarations and functions
Namespace

    declarative region that provides a scope to the identifiers inside it.
        (the names of types, functions, variables, etc.)
    great for creating effective scope

```
namespace myNamespace
{
    int a, b;
}

using namespace std;
using namespace myNamespace;
a = 10
b = 20
cout <<"a="<<a<<"b="<<b;

ifstream - input file stream : used to open files
    ifstream in(argv[1]);
    if (!in) return 1; // if it this resulted in an error return 1
```


## Arguments
### Argc and argv
EX:
#include <iostream>
#include <string>
using namespace std;

```
int main(int argc, char* argv[])
{
    cot << endl << "argc = " << argc;
    for (int i = 0; i < argc ; ++i)
    {
        cout << endl << :"argv[" << i << "] = ";
        cout << argv[i];
    }
    return 0;
}
```

// the size of argv[] is argc.
// argv[] is an array of pointers to char*


## Conditional formating
```
    ostream& out = (argc > 2) ? *(new ofstream(argv[2])) : cout;
    <boolean> ? <true expression> : <false expression>
```
## looping
```
int main(int argc, char* argv[])
{ 
    ifstream in(argv[1]);
    if (!in) return 1;
    ostream& out = (argc > 2) ? *(new ofstream(argv[2])) : cout;
    if (!out) return 2;

    string line;
    while (in >> line)
    {
        out << line << endl;
    }
    if (&out != &cout) delete(&out);
    in.close();
    return 0;
}
```

Preprocessors
"#define" = set a variable to a value - #define MATHSCORE 100
"#include" = insert a particular header from another file
"#if and #endif

```
Control Statements
    Selection
        if
        if-else
        switch - a series of if statements. If this or this or this then this.
    iteration
        loops
    Jump
        break
        continue
        return
```

## Iteration
```
int rows = 2;
int cols = 3;
int## array = new int*[rows];
for(int i = 0; i < rows: ++i)
    array[i] = new int[cols]
```

## Array
an array is a lot like a list in python
```
using namespace std;

int main() {

    int luckyNums[] = {4, 5, 6, 8};
    cout << luckyNums[2];
    
    return 0;
}
```
the brackets define luckyNums as an array, the curly brackets define the parameters of the list. the number 2 is the index of the array and would return 6. you can change arrays also.

## Conditional Statements
&& means and
|| means or
if(){}
else if(){}
! means not
else{}

## while loops
```
int main(){
    int index = 1;
    while(index <= 5){
        cout << index << endl;
        index++;
    }
}
```
you can also do the reverse where you execute then check condition:
```
int main(){
    int index = 6;
    do{
        cout << index << endl;
        index++;
    }while(index <= 5);
}
```
first the code executes, then the condition is checked. 

## for loops
```
int main() {
    for(int i = 1; index <= 5; i++){ // declair; condition; 
        cout << i << endl
    }
}
```

## 2d Array and nested for loops
2d array
```
int main(){
    int numberGrid[3][5] = { 
        {1, 2, 3, 4, 5}
        {6, 7, 8, 9, 10}
        {11, 12, 13, 14 15}
    }
    return 0
}
```
// note that it is crucial to specify 3 and 2. 3 arrays inside of numberGrid and inside each nested array. 

nested for loop
```
int main(){
    int numberGrid[3][5] = { 
        {1, 2, 3, 4, 5}
        {6, 7, 8, 9, 10}
        {11, 12, 13, 14 15}
    }
    
    for(int i = 0; i < 3; i++){
        for(int j = 0; j < 5; j++){
            cout << numberGrid[i][j];
        }
        cout << endl;
    }
    return 0
}
>>>12345
>>>678910
>>>1112131415
```

## pointers
```
int main(){
    int age = 19;
    double gpa = 2.7;
    string name = "Mike";

    cout << &age; //& tells the computer to return the memory address of the variable age.

    return 0'
}
```
Try * and &:
```
int main(){
    int age = 19;
    int *pAge = &age;
    double gpa = 2.7;
    double *pGpa = &gpa;
    string name = "Mike";

    cout << pAge;
    cout << *pAge;

    return 0'

>>>MEMORY ADDRESS LONG COMPLEX NUMBER
>>> 19
}
```

## cerr
cerr is used to show information on the error screen. Used for debugging?
```
if (argc < 3)
{
   cerr << "Please provide name of input and output files";
   return 1;
}
cout << "Input file: " << argv[1] << endl;
ifstream in(argv[1]);
if (!in)
{
   cerr << "Unable to open " << argv[1] << " for input";
   return 2;
}
cout << "Output file: " << argv[2] << endl;
ofstream out(argv[2]);
if (!out)
{
   in.close();
   cerr << "Unable to open " << argv[2] << " for output";
   return 3;
}
```


# Language Library

### `#`Include
`#`Include is always placed at the top to include a file from the C++ Language Library
It is always preceeded by a file name such as <iostream> or Input output stream.

### cout
cout is equivelant to print in python
```
int main(){
    int a = 1
    std::cout << a
    return 0
}
>>> 1
```
note that std stands for short form standard, it contains built-in classes and declares functions

### const
const declares a variable as non-changable
```
int main(){
    const int a = 1
    std::cout << a
    return 0
}
>>> 1
```

### double
double is equivelant to float in python. Integer with decimals.
```
int main() {
    double a = 10 //or 10.0
    int b = 3
    double z = a / b
    std::cout << z
    return 0
}
>>> 3.3333
```

### plus plus or minus minus
++ or -- are equivelant to += 1 and -= 1
```
int x = 1;
x++;
stx::cout << x;
return 0;
>>> 2
```
note this use of ++
```
int x = 10;
int y = x++;
int z = ++x;
std::cout << x;
std::cout << y;
std::cout << z;
return 0;
>>> 11
>>> 10
>>> 12
```
y in this case is equal to the initial value of x(10), and x is then set to x+1, or 11. z is set to x + 1 as well as x. because it is added to twice it will be 12

### endl
endl is used to print on the next line down.
```
int a = 1
int b = 2
std::cout << "a = " << a;
std::cout << "b = " << b;
return 0
>>> a = 1b = 2
```
instead try this
```
int a = 1
int b = 2
std::cout << "a = " << a << std::endl;
std::cout << "b = " << b;
return 0
>>> a = 1
>>> b = 2
```

### namespace
use namespace to avoid repetition with std

```
`#`input <iostream>

using namespace std;

int main(){
    int a = 1
    int b = 2
    cout << "a = " << a << sendl
         << "b = " << b;
return 0
}
>>> a = 1
>>> b = 2
```

### cin
cin is the opposite of cout. instead of printing a value it is used to imput a value.
```
#input <iostream>

using namespace std;

int main(){
    cout << "Enter a Value: ";
    double value;
    cin >> value;
    cout << value;
    return 0
}
>>> Enter a Value: //you then enter a number
10.5
>>> 10.5 // where value is now equal to 10.5
```
### floor / pow

floor takes a double and creates an int

```
double int a = floor(1.2); //a = 1
```

pow lets you put x to the power of y
``` 
int a = pow(2, 3) //a=8
```

### Variable types
float is used to include integers, ends with f. 
long (Long int) ** end value with L
char is a single character
bool is boolean value - true; or false;

### <cstdlib> and <ctime>
randome library!
* rand()
* time(0) - number of seconds since Jan 1970
```
int main() {
    long elapsedSeconds = time(0);
    srand(elapsedSeconds); // or srand(time(0))
    int number = rand() % 10;
    cout << number;
    return 0;
}
```


### Call by reference - pointer

```
void swap(int& x, int& y) // these must be passes l-value arguments
{
    FUNCTION
}

int main()
{
    int a = 10;
    int b = 20;
    swap(a, b); // these are l values becaue they refer to another input.
    swap(10, 20); // this would throw a compile error.
};
```

Note that the dereferencing operator (*) can access the contents of the memory location it points to. 

Note that address-of operator (&) returns an r-value address of its l-value argument.


### 2d array - creation

```
int** a = new int*[rowCount];
for(int i = 0; i < rowCount; ++ i)
    a[i] = new int[colCount];
```

### identify and cout words separated by white space

```
int countWords(string str)
{
    stringstream ss(str); // makes individual words?
    string word;
    int count = 0;
    while (ss >> word) // while there are individual words it will store them in word
    {
        count++;
        cout << word << endl
    }
    return count;
}
int main()
{
    string str = "YA YA YA YA YA YA YES";
    cout << countWords(str);
    return 0
}
```

## Debugging
### try block
your code is as follows:
```
age = read_int("Enger your age: ");
```
to catch any input that is not correct(ie not an int) than you can throw try and catch blocks
```
try
{
    age = read_int("Enger your age: ");
}
catch(...) // many typesof catch statements. 
{
    cerr << endl << "Undefined exception in read_int";
    about();
}


### catch block



